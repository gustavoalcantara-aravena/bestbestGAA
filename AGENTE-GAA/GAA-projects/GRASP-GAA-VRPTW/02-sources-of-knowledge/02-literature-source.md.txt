Algorithmic Architectures for the Vehicle Routing Problem with Time Windows: A Comprehensive Synthesis for Automated Heuristic Design
1. Introduction and Problem Landscape
The Vehicle Routing Problem with Time Windows (VRPTW) represents one of the most intellectually demanding and practically significant challenges in the field of combinatorial optimization. It serves as a definitive generalization of the classical Capacitated Vehicle Routing Problem (CVRP), introducing temporal constraints that fundamentally alter the structure of the solution space and the nature of effective search algorithms. In the VRPTW, a fleet of vehicles, typically homogeneous and based at a single central depot, must service a spatially distributed set of customers. Each customer requires a specific quantity of goods and, crucially, must be serviced within a strict time interval known as a time window. The objective is classically hierarchical: primarily to minimize the number of vehicles required (fleet size), and secondarily to minimize the total travel distance or time incurred by the fleet.1
The complexity of the VRPTW is classified as NP-hard, a designation that stems from its composition of two other NP-hard problems: the Traveling Salesman Problem (TSP) and the Bin Packing Problem (BPP). However, the addition of scheduling constraints adds a third layer of complexity related to the Scheduling Problem with Release Times and Deadlines. This tripartite structure implies that exact methods—such as branch-and-price or column generation—while theoretically sound, often face exponential scaling issues that render them impractical for large-scale, real-time industrial applications.3 Consequently, the operational research community has spent decades developing approximate methods: heuristics and metaheuristics that trade guaranteed optimality for computational tractability and high-quality solutions.
In the contemporary era of artificial intelligence, the focus has shifted from the manual crafting of these heuristics to Automated Algorithm Design (AAD). Frameworks such as Hyper-heuristics, Genetic Programming (GP), and Reinforcement Learning (RL) attempt to "evolve" or "learn" optimal heuristic strategies. However, these automated systems are not magic; they require a rich library of algorithmic primitives—a "genetic soup" of constructive logic, neighborhood operators, feasibility checks, and acceptance criteria—from which to build superior solvers.5
This report provides an exhaustive, granular analysis of the peer-reviewed literature surrounding VRPTW solution methods. It is specifically structured to facilitate knowledge extraction for AAD frameworks. By dissecting the anatomy of foundational heuristics, cataloging the mechanics of neighborhood operators, and elucidating the efficient feasibility checks proposed by Savelsbergh, this document serves as a blueprint for the component library of an automated heuristic generation system.
1.1 The Shift to Automated Design
Traditional research in VRPTW has been characterized by the "arms race" of metaheuristics. Researchers would manually tweak neighborhood structures, adjust cooling schedules in Simulated Annealing, or design complex crossover operators for Genetic Algorithms to squeeze out marginal improvements on benchmark instances. This process is labor-intensive and requires deep domain expertise.
Automated Algorithm Design seeks to automate this trial-and-error process. There are two primary approaches discussed in the literature:
Selection Hyper-heuristics: These frameworks operate on a fixed set of low-level heuristics (e.g., 2-opt, Swap, Relocate) and use a high-level strategy (often trained via machine learning) to select the best heuristic to apply at any given state of the search.8
Generation Hyper-heuristics: These systems use evolutionary computation, such as Genetic Programming (GP), to construct new heuristics from scratch. They combine basic terminals (e.g., distance, remaining capacity, time window width) and functions (e.g., addition, minimization) to create novel scoring functions or routing policies.5
For either approach to succeed, the "building blocks" provided to the system must be robust, diverse, and capable of capturing the nuances of the VRPTW. This report systematically identifies these blocks.
2. Mathematical Formulation and Constraint Handling
To generate effective algorithms, an automated system must possess an intrinsic understanding of the problem's constraints. The mathematical formulation of the VRPTW defines the boundaries of the search space.
2.1 The Multi-Commodity Network Flow Model
The standard integer programming formulation for the VRPTW is defined on a directed graph $G = (V, A)$. The vertex set $V = \{0, 1,..., n, n+1\}$ typically denotes the depot with two distinct nodes: node 0 represents the depot at the start of the route, and node $n+1$ represents the depot at the end. The set of customers is $C = \{1,..., n\}$. The set of arcs $A$ represents feasible connections between locations.3
Decision Variables:
$x_{ijk}$: A binary decision variable that is equal to 1 if vehicle $k$ travels directly from vertex $i$ to vertex $j$, and 0 otherwise.
$s_{ik}$: A continuous decision variable representing the time at which vehicle $k$ begins service at vertex $i$.
Objective Function:
The objective is usually hierarchical. In hyper-heuristic frameworks, this hierarchy must be encoded into the fitness function.


$$\text{Minimize } \alpha \sum_{k \in K} \sum_{j \in V} x_{0jk} + \beta \sum_{k \in K} \sum_{i \in V} \sum_{j \in V} c_{ij} x_{ijk}$$

Where $\alpha \gg \beta$, prioritizing the reduction of the fleet size ($K$) over the reduction of total travel cost ($c_{ij}$).3
Constraints:
Flow Conservation: Each customer must be entered and left exactly once.

$$\sum_{k \in K} \sum_{j \in V} x_{ijk} = 1, \quad \forall i \in C$$
$$\sum_{i \in V} x_{ihk} - \sum_{j \in V} x_{hjk} = 0, \quad \forall h \in C, \forall k \in K$$
Capacity Constraints: The total demand on any route $k$ must not exceed the vehicle capacity $Q$.

$$\sum_{i \in C} d_i \sum_{j \in V} x_{ijk} \leq Q, \quad \forall k \in K$$
Time Window Constraints: This is the distinguishing feature of the VRPTW. Service at customer $i$ must begin within the window $[e_i, l_i]$.

$$e_i \leq s_{ik} \leq l_i, \quad \forall i \in V, \forall k \in K$$
Schedule Consistency: The service start times must be consistent with travel times. If vehicle $k$ travels from $i$ to $j$, service at $j$ cannot start before service at $i$ is finished plus travel time.

$$x_{ijk} (s_{ik} + t_{service} + t_{ij} - s_{jk}) \leq 0$$

This nonlinear constraint is typically linearized using a "Big-M" formulation in Mixed Integer Linear Programming (MILP), but in heuristic design, it serves as the logic for the "Forward Time Slack" check.3
2.2 Soft Time Windows and Penalty Functions
A critical insight from the literature for automated algorithm design is the handling of infeasibility. In a rigid "hard" time window model, the search landscape is disjoint; an evolutionary algorithm might struggle to migrate from one local optimum to another because the intermediate solutions are infeasible and thus discarded.
Strategic Oscillation:
To overcome this, advanced frameworks often utilize the Vehicle Routing Problem with Soft Time Windows (VRPSTW) formulation as a relaxation strategy. Here, constraints are relaxed into the objective function using penalties. This allows the solver to traverse infeasible regions of the search space to reach high-quality feasible solutions.13
Taillard’s Formulation:
Taillard et al. proposed a formulation where the time window $[e_i, l_i]$ is soft. A violation of the upper bound $l_i$ incurs a cost, while arriving before $e_i$ incurs a waiting time (costing zero or a small penalty depending on the model, but strictly affecting schedule duration).
The objective function transforms to:


$$f(s) = \sum_{k} \text{Distance}_k + \sum_{i \in V} \alpha_i \times \max(0, s_i - l_i)$$

where $\alpha_i$ is a penalty coefficient.
Penalty Shapes for AAD Primitives:
Automated design frameworks can select from different penalty functions as "terminals" in their evolutionary logic:
Linear Penalty: $\alpha \times \text{violation}$. Useful for early exploration where broad searches are needed.
Quadratic Penalty: $\alpha \times \text{violation}^2$. Useful for late-stage intensification, providing a steep gradient forcing the solution back to feasibility.15
Dynamic Penalties: The coefficient $\alpha$ can be adjusted dynamically during the search (e.g., increasing $\alpha$ if the population is consistently infeasible), a strategy often found in Genetic Algorithms.13
3. Constructive Heuristics: The Foundation of Solution Initialization
Constructive heuristics build a solution from scratch by adding customers one by one to a set of routes. For generation hyper-heuristics, these heuristics provide the structural skeleton (the loop of inserting customers) while the hyper-heuristic evolves the "brain" (the criteria for which customer to insert and where).5
3.1 Solomon’s Sequential Insertion Heuristic (I1)
Solomon’s I1 heuristic is arguably the most referenced constructive method in the VRPTW literature. It builds routes sequentially: a route is initialized, filled with customers until no more can be feasibly added, and then a new route is started. This sequential nature makes it particularly effective for minimizing the number of vehicles (the primary objective).17
The Logic Structure (Knowledge for Extraction):
Solomon’s I1 revolves around two key decision criteria, $c_1$ and $c_2$, which are prime candidates for evolution in a Genetic Programming framework.
Initialization: The first customer of a new route is selected to "seed" the route. This is typically the unrouted customer that is farthest from the depot or has the earliest deadline.
AAD Insight: A hyper-heuristic could evolve a custom "seeding function" that considers a weighted mix of distance, urgency, and demand.
Insertion Cost ($c_1$): For each unrouted customer $u$, the heuristic calculates the best position to insert it into the current route. Let the route be a sequence of nodes $0 \to i_1 \to... \to i_p \to 0$. The cost of inserting $u$ between adjacent nodes $i$ and $j$ is calculated as:

$$c_1(i, u, j) = \alpha_1 \times c_{11}(i, u, j) + \alpha_2 \times c_{12}(i, u, j)$$
Distance Contribution ($c_{11}$): $d_{iu} + d_{uj} - \mu d_{ij}$. This represents the detour distance. The parameter $\mu$ (savings factor) controls how much we value preserving the original arc.
Time Contribution ($c_{12}$): $b_{ju} - b_j$. This represents the delay in service start time at the next customer $j$ caused by visiting $u$. This is crucial because delaying $j$ might consume the slack of all subsequent customers in the route.18
Selection Criterion ($c_2$): After identifying the best insertion position for every unrouted customer, the algorithm must choose which customer to actually insert. Solomon proposes maximizing the benefit:

$$c_2(i, u, j) = \lambda d_{0u} - c_1(i, u, j)$$

This is a "generalized savings" concept. It prefers customers that are far from the depot (hard to service later) but have a low insertion cost now.
Automated Design Application:
In a GP framework, the fixed coefficients $\alpha_1, \alpha_2, \lambda$ and the primitive variables ($d_{iu}, b_{ju}, d_{0u}$) become the terminal set. The GP evolves the algebraic expression. For instance, an evolved heuristic might discover that for "clustered" instances, the distance term should be squared, or that "Urgency" (time until deadline) is more important than distance.5
3.2 Parallel Route Construction
Unlike sequential insertion, parallel heuristics initialize a fixed number of vehicles $K$ and build all routes simultaneously.
The Sweep Algorithm: Geometrically sweeps a ray around the depot, adding customers to the current vehicle until capacity/time is reached. Effective for clustered data but weak on time windows.
Parallel Insertion: Generalizes Solomon’s I1 to consider insertion into any active route.
AAD Relevance: Parallel construction is naturally suited for population-based metaheuristics (like GAs) where the chromosome represents a partition of customers, and the decoder builds the routes. It prevents the "last route" problem of sequential heuristics, where the final vehicle is often underutilized and travels a chaotic path to pick up leftovers.2
4. The Library of Neighborhood Operators
Once an initial solution is constructed, it is almost never optimal. Improvement heuristics, or Local Search operators, are applied to perturb the solution and find better neighbors. For an automated framework (specifically Selection Hyper-heuristics), this list of operators constitutes the "action space." The system must learn which operator to apply based on the current problem state.10
We categorize these operators by their topological effect and their impact on VRPTW constraints.
4.1 Intra-Route Operators (TSP Optimizers)
These operators function within a single route. They do not change the fleet size or the assignment of customers to vehicles. Their primary goal is to reduce travel time/distance, thereby creating "slack" (free time) that enables subsequent inter-route moves.
Operator
Mechanism
Impact on VRPTW
Complexity (Check)
2-Opt
Removes two edges $(i, i+1)$ and $(j, j+1)$, adding $(i, j)$ and $(i+1, j+1)$. Effectively reverses the segment between $i+1$ and $j$.
High Risk: Reversing a segment inverts the service order. If time windows are tight, this is likely infeasible.
$O(1)$ with Savelsbergh
Or-Opt
Moves a contiguous chain of $k$ customers (typically $k \in \{1, 2, 3\}$) to a different position in the same route.
High Utility: Preserves the internal orientation of the moved chain. Much friendlier to time windows than 2-Opt.
$O(1)$ with Savelsbergh
Relocate (Intra)
Moves a single node $u$ to a new position in the same route.
Special case of Or-Opt ($k=1$). Good for fine-tuning.
$O(1)$
Exchange (Intra)
Swaps positions of two nodes $u$ and $v$ in the same route.
Can disrupt time consistency significantly if $u$ and $v$ are far apart.
$O(1)$

AAD Insight: Automated systems often learn to prioritize Or-Opt over 2-Opt in instances with tight time windows (e.g., Solomon R1 class) because 2-Opt generates too many infeasible neighbors.20
4.2 Inter-Route Operators (VRP Optimizers)
These operators move customers between routes. They are essential for reducing the number of vehicles (by emptying a route) and for balancing load/time.
Operator
Mechanism
Impact on VRPTW
Complexity (Check)
Relocate (Inter)
Moves node $u$ from Route A to Route B.
Primary mechanism for fleet reduction (emptying small routes).
$O(1)$
Swap (1-1)
Exchanges node $u$ (Route A) with node $v$ (Route B).
Useful for spatial clustering adjustments.
$O(1)$
Cross-Exchange
Swaps two segments of arbitrary length between Route A and Route B.
Powerful: Can reconfigure large portions of the solution. Includes Swap and Relocate as special cases.
$O(N^2)$ (expensive)
2-Opt*
Cuts Route A and Route B; reconnects the first part of A to the second part of B, and vice versa.
Preserves tail orientation. Excellent for merging routes.
$O(1)$

The Cross-Exchange Operator:
Cross-exchange is particularly notable for automated design. Because it generalizes several other operators (Swap is a cross-exchange of length 1 segments; Relocate is a cross-exchange where one segment is empty), a hyper-heuristic can theoretically just use Cross-Exchange. However, the computational cost ($O(N^2)$ to scan all segment lengths) usually leads automated systems to prefer the specialized, faster operators (Relocate, Swap) in early search phases, reserving Cross-Exchange for stagnation phases.20
5. Efficient Feasibility Checking: The Engine of Optimization
In a typical local search, checking the validity of a move (e.g., "Can I insert customer $u$ here?") requires calculating the arrival times for all subsequent customers in the route to ensure no time window is violated. This takes $O(n)$ time. Since a metaheuristic might evaluate millions of moves, an $O(n)$ check is prohibitively slow.
Savelsbergh (1992) introduced the methodology of Forward and Backward Time Slacks, which allows feasibility checks in $O(1)$ constant time. This is an absolute requirement for any high-performance automated heuristic framework.23
5.1 The Logic of O(1) Checks
The core idea is to maintain global variables for each segment of a route (or subtree in advanced implementations) that summarize the temporal constraints.
Definitions:
For any segment or route, we maintain:
Duration ($D$): Total travel + service time.
Earliest Start ($E$): The earliest possible time the segment can start to be feasible internally.
Latest Start ($L$): The latest time the segment can start without violating any internal time window.
Forward and Backward Variables:
To check the concatenation of two segments (e.g., connecting Node $i$ to Node $j$ in a 2-Opt* move), we utilize:
Forward Variables (from Depot to $i$): $E_i$ (Earliest arrival at $i$), $L_i$ (Latest arrival at $i$ that allows feasibility up to $i$), $W_i$ (Cumulative waiting time).
Backward Variables (from $j$ to Depot): These summarize the constraints of the "tail" of the route starting at $j$.
The Feasibility Test:
To check if connecting $i \to j$ is valid:
Time Window Check: The earliest arrival at $j$ (derived from $E_i + service_i + t_{ij}$) must be $\leq$ the latest allowed start time at $j$ (derived from backward variables).
Slack Logic: The check essentially computes if the "push" (delay) caused by the connection consumes more than the available "slack" in the downstream segment.
Implication for AAD:
When generating heuristics via GP, the terminals should not just be raw data ($e_i, l_i$). They must include these pre-calculated Savelsbergh variables (Slack_Forward, Slack_Backward, Next_Earliest_Departure). This allows the evolved logic to make sophisticated decisions about "tightness" without re-running the full schedule simulation.19
6. Metaheuristic Strategies and Architectures
While neighborhood operators define how to move, metaheuristics define where to move and when to accept a move. These provide the high-level control structures that automated frameworks attempt to optimize.
6.1 Tabu Search (TS)
Tabu Search explores the solution space by moving to the best neighbor (even if it is worse than the current solution) to escape local optima.
Tabu List: A short-term memory that forbids reversing recent moves (e.g., "Do not move Customer 5 back to Route 1").
Granular Tabu Search: Introduced by Toth and Vigo. It restricts the neighborhood search to a "candidate list" of promising arcs (e.g., arcs with low distance cost). This drastically reduces the search space size, a strategy often emulated by "pruning" logic in hyper-heuristics.1
AAD Application: Hyper-heuristics often parameterize the Tabu tenure (how long a move is forbidden). An adaptive system might learn to increase tenure when the search is cycling and decrease it when intensifying.
6.2 Genetic Algorithms (GA) and Memetic Algorithms
GAs evolve a population of solutions. The key challenge in VRPTW is the "permutation" representation: simply crossing over two routes can easily create invalid solutions (missing or duplicate customers).
Representation: Solutions are often represented as a giant tour (permutation of numbers $1...n$) without delimiters. A "Split" procedure (optimal partitioning) is then used to break this giant tour into feasible routes with minimal cost.17
Crossover Operators:
Order Crossover (OX): Preserves relative order.
Best Cost Route Crossover (BCRC): Extracts a route from Parent A and inserts its customers into Parent B in the best possible positions. This is highly effective for VRPTW as it respects spatial clusters.
Memetic Algorithms: These are hybrids where a Local Search (e.g., 2-Opt) is applied to every child generated by the GA. This "education" step ensures that the population consists only of local optima, significantly improving convergence.1
6.3 Adaptive Large Neighborhood Search (ALNS)
ALNS, developed by Ropke and Pisinger, is the current gold standard for many VRP variants and serves as the direct precursor to Selection Hyper-heuristics. Unlike local search (which makes small moves), ALNS destroys a large part of the solution (removes $N$ customers) and repairs it.27
The Mechanism (Knowledge for AAD):
ALNS chooses from a library of Destroy and Repair operators using a roulette wheel selection based on past performance.
Destroy Operators:
Random Removal: Stochasticity.
Worst Removal: Removes customers that cause the largest detour/delay.
Shaw Removal (Relatedness): Removes a group of customers that are "related" (close in distance, time, and demand). This is profound: by removing a cluster of related customers, it becomes easier to re-insert them together in a more optimal configuration.27
Repair Operators:
Regret Insertion (Regret-k): Instead of inserting the customer with the cheapest cost, it inserts the customer that would be most expensive if left for later (Max-Regret). This lookahead prevents the algorithm from painting itself into a corner with difficult customers.28
AAD Connection: ALNS is a hyper-heuristic. The "adaptation" layer (updating weights of operators) is a form of online Reinforcement Learning. Modern AAD frameworks effectively try to "evolve" the ALNS logic itself—for example, by evolving new Destroy operators or new Relatedness measures.30
7. Hyper-heuristics and Automated Design Frameworks
This section addresses the core of the user's request: approaches suitable for knowledge extraction in automatic algorithm generation.
7.1 Selection Hyper-heuristics
These frameworks manage a set of low-level heuristics (LLH). The goal is to select the sequence of heuristics $h_1, h_2,..., h_k$ that solves the instance most effectively.
State Feature Extraction (The "Senses" of the Algorithm):
To make intelligent decisions, the hyper-heuristic must "see" the problem state. Key features identified in the literature include:
Global Metrics: Current objective value, number of vehicles.
Diversity Metrics: Entropy of the population (if population-based).
Constraint Metrics: Percentage of routes with tight time windows; percentage of vehicle capacity used.
History Metrics: Success rate of "Swap" in the last 100 iterations.
Learning Mechanisms:
Choice Functions: Score heuristics based on $f_1$ (recent performance), $f_2$ (pairwise performance), and $f_3$ (time elapsed).
Machine Learning (Apprenticeship Learning): Train a Neural Network or Decision Tree to mimic an "expert" heuristic (like ALNS) or to predict the best heuristic given the state features.8
7.2 Generation Hyper-heuristics (GP)
These frameworks evolve the code of the heuristic itself.
Terminal Sets for VRPTW:
Based on the analysis of Solomon, Savelsbergh, and ALNS, a robust terminal set for GP must include:
Static Terminals: Dist(i,j), Demand(i), ReadyTime(i), DueDate(i), ServiceTime(i).
Dynamic Terminals (State-dependent): CurrentTime, RemainingCapacity, WaitingAt(i).
Computed Terminals (Savelsbergh): ForwardSlack(i), BackwardSlack(i), TimeWarp(i).
Example of Evolved Logic:
A GP might evolve a constructive insertion score like:


$$Score = \frac{Dist(i, u)}{\text{RemainingCapacity}} + \beta \times (\text{DueDate}(u) - \text{CurrentTime})$$

This logic represents a trade-off between distance-efficiency and urgency, scaled by capacity. The AAD system discovers the optimal balance and the value of $\beta$ for specific instance classes.5
8. Benchmark Analysis: Solomon and Homberger Suites
For an automated system to generalize, it must be trained on diverse data. The Solomon (1987) and Homberger (1999) benchmarks are the standard training grounds. Understanding their characteristics allows AAD frameworks to learn "context-aware" strategies.32
8.1 Instance Classes and Heuristic Implications
Class
Distribution
Horizon
Characteristics & Heuristic Strategy
R1
Random
Short
Constraint-Heavy: Tight time windows mean few customers per vehicle. Routes are defined by time, not capacity. Strategy: Heuristics must prioritize temporal packing (Or-opt). "Urgency" terminals are critical.
R2
Random
Long
Capacity-Heavy: Vehicles can serve many customers. Resembles CVRP. Strategy: Spatial optimization (2-Opt, Swap) dominates.
C1
Clustered
Short
Geometric Structure: Customers form distinct clusters. Strategy: "Cluster-first" heuristics work best. The solver should finish one cluster before moving to the next.
C2
Clustered
Long
Easy Packing: Large capacity allows serving entire clusters in one go. Often solved to optimality.
RC1
Mixed
Short
Hybrid Challenge: Contains both structure and randomness with tight constraints. Requires balanced strategies.
RC2
Mixed
Long
Hybrid Challenge: Mixed structure with looser constraints.

Homberger Instances:
These extend the Solomon classes to 200, 400, 600, 800, and 1000 customers. They test the scalability of the generated algorithms. A heuristic that relies on $O(N^2)$ operators (like Cross-Exchange) might fail on Homberger-1000 due to time limits, pushing the AAD system to evolve lighter, $O(N)$ or $O(1)$ strategies.1
9. Conclusion
The transition from manually designed metaheuristics to automated algorithm design for the VRPTW is not merely a change in method, but a shift in abstraction. Instead of optimizing routes, we are now optimizing the logic that builds routes. This report has synthesized the foundational components required to construct such systems.
The literature confirms that a robust component library for AAD must include:
Mathematical Rigor: The utilization of Taillard’s soft time window formulations to ensure search space connectivity.
Algorithmic Efficiency: The hard-coding of Savelsbergh’s forward/backward slack updates to enable constant-time feasibility checks, freeing the evolutionary process to focus on high-level strategy.
Diverse Operators: A mix of intra-route (2-Opt, Or-Opt) and inter-route (Relocate, Swap, Cross-Exchange, 2-Opt*) operators to handle both spatial and temporal optimization.
Rich Terminal Sets: The inclusion of "deep" features like Regret, Urgency, and Relatedness (from Shaw removal) in the genetic programming primitives, rather than relying solely on raw distance data.
Context Awareness: The ability to detect instance characteristics (Clustered vs. Random, Short vs. Long Horizon) and adapt the heuristic strategy accordingly, as evidenced by the performance differences across Solomon’s benchmarks.
By integrating these elements, researchers can build automated frameworks capable of generating VRPTW solvers that not only rival but potentially surpass the best human-designed algorithms in adaptability and robustness.
Table 1: Summary of Key Neighborhood Operators for VRPTW AAD
Operator Category
Operator Name
Time Complexity (with Savelsbergh)
Description
Primary Use Case in AAD
Intra-Route
2-Opt
$O(1)$
Reverses segment order.
Local smoothing; reducing distance in loose TW instances.
Intra-Route
Or-Opt
$O(1)$
Moves chain of length $k$.
Improving time feasibility; preserving segment orientation.
Inter-Route
Relocate (1-0)
$O(1)$
Moves node to different route.
Reducing fleet size (emptying routes); load balancing.
Inter-Route
Swap (1-1)
$O(1)$
Exchanges two nodes.
Optimizing spatial clustering without changing fleet size.
Inter-Route
2-Opt*
$O(1)$
Swaps route tails.
Merging routes; fixing crossing paths between vehicles.
Inter-Route
Cross-Exchange
$O(N^2)$ (scan)
Swaps chains between routes.
Large-scale restructuring; escaping deep local optima.
Destroy
Shaw Removal
$O(N \log N)$
Removes related nodes.
Creating intelligent "holes" for re-optimization (ALNS).
Repair
Regret Insertion
$O(N^2)$
Inserts based on opportunity cost.
Constructing robust solutions; handling "difficult" nodes first.

Table 2: Feature Terminals for Genetic Programming in VRPTW
Feature Class
Variable Name
Definition/Logic
Source Logic
Spatial
Dist(u, v)
Euclidean distance.
Nearest Neighbor Heuristics
Spatial
Dist(Depot, u)
Distance from depot.
Solomon's I1 (Seeding)
Temporal
ReadyTime(u)
Start of time window ($e_u$).
VRPTW Constraints
Temporal
DueDate(u)
End of time window ($l_u$).
VRPTW Constraints
Temporal
ServiceTime(u)
Duration of service.
VRPTW Constraints
Derived
Urgency(u)
$l_u - \text{CurrentTime}$.
Constructive Heuristics
Derived
WaitTime(u)
$\max(0, e_u - \text{Arrival})$.
Cost Function
Derived
Slack(u)
$L_u - E_u$ (Max delay allowed).
Savelsbergh (1992)
Derived
Regret(u)
Cost(2nd best) - Cost(Best).
ALNS / Regret Insertion

End of Report.
Obras citadas
Vehicle Routing Problem with Time Windows, Part II: Metaheuristics - IDEAS/RePEc, fecha de acceso: enero 3, 2026, https://ideas.repec.org/a/inm/ortrsc/v39y2005i1p119-139.html
Vehicle routing with time windows: An overview of exact, heuristic and metaheuristic methods - Journal of King Saud University, fecha de acceso: enero 3, 2026, https://jksus.org/vehicle-routing-with-time-windows-an-overview-of-exact-heuristic-and-metaheuristic-methods/
Chapter 3 VEHICLE ROUTING PROBLEM WITH TIME WINDOWS, fecha de acceso: enero 3, 2026, http://alvarestech.com/temp/vrptw/Vehicle%20Routing%20Problem%20with%20Time%20Windows.pdf
A New Class of Compact Formulations for Vehicle Routing Problems - arXiv, fecha de acceso: enero 3, 2026, https://arxiv.org/pdf/2403.00262
Selection and Generation Hyper-heuristics for Solving the Vehicle ..., fecha de acceso: enero 3, 2026, http://www.jcobayliss.net/papers/GECCO2016.pdf
(PDF) Generation of VNS Components with Grammatical Evolution ..., fecha de acceso: enero 3, 2026, https://www.researchgate.net/publication/259282964_Generation_of_VNS_Components_with_Grammatical_Evolution_for_Vehicle_Routing
Routing - SciTePress, fecha de acceso: enero 3, 2026, https://www.scitepress.org/publishedPapers/2024/130589/pdf/index.html
Improving Performance of a Hyper-heuristic Using a Multilayer ..., fecha de acceso: enero 3, 2026, https://people.cs.nott.ac.uk/pszeo/docs/publications/ukci2015.pdf
Selection and Generation Hyper-heuristics for Solving the Vehicle Routing Problem with Time Windows - ResearchGate, fecha de acceso: enero 3, 2026, https://www.researchgate.net/publication/305727202_Selection_and_Generation_Hyper-heuristics_for_Solving_the_Vehicle_Routing_Problem_with_Time_Windows
Learning to Search for Vehicle Routing with Multiple Time Windows - arXiv, fecha de acceso: enero 3, 2026, https://arxiv.org/html/2505.23098v1
Solving Large-Scale Vehicle Routing Problems with Time Windows: The State-of-the-Art - Cirrelt, fecha de acceso: enero 3, 2026, https://www.cirrelt.ca/documentstravail/cirrelt-2010-04.pdf
A generalized formulation for vehicle routing problems - arXiv, fecha de acceso: enero 3, 2026, https://arxiv.org/pdf/1606.01935
Modeling and Solving the Multi-Objective Vehicle Routing Problem with Soft and Fuzzy Time Windows - MDPI, fecha de acceso: enero 3, 2026, https://www.mdpi.com/2079-8954/12/12/560
Time-Window Relaxations in Vehicle Routing Heuristics - Cirrelt, fecha de acceso: enero 3, 2026, https://www.cirrelt.ca/documentstravail/cirrelt-2013-43.pdf
OPUS - A branch-and-price algorithm for the multi-depot heterogeneous-fleet pickup and delivery problem with soft time, fecha de acceso: enero 3, 2026, https://opus4.kobv.de/opus4-mpc/files/67/Bettinelli2014_Article_ABranch-and-priceAlgorithmForT.pdf
A Tabu Search Heuristic for the Vehicle Routing Problem with Soft Time Windows - ArODES, fecha de acceso: enero 3, 2026, https://arodes.hes-so.ch/record/8217/files/Author%20postprint.pdf
Heuristics for Vehicle Routing Problem: A Survey and Recent Advances - arXiv, fecha de acceso: enero 3, 2026, https://arxiv.org/pdf/2303.04147
A sequential insertion heuristic for the vehicle routing problem with time windows with relatively few customers per route - IDEAS/RePEc, fecha de acceso: enero 3, 2026, https://ideas.repec.org/p/ant/wpaper/2000014.html
Sequential Insertion Heuristic with Adaptive Bee Colony Optimisation Algorithm for Vehicle Routing Problem with Time Windows | PLOS One - Research journals, fecha de acceso: enero 3, 2026, https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0130224
Vehicle Routing Problem with Time Windows, Part II ... - SciSpace, fecha de acceso: enero 3, 2026, https://scispace.com/pdf/vehicle-routing-problem-with-time-windows-part-ii-4tzmnpdxqc.pdf
A New Two-phase Hybrid Metaheuristic for Vehicle Routing Problem with Time Windows, fecha de acceso: enero 3, 2026, https://easts.info/on-line/proceedings/vol9/PDF/P181.pdf
OPUS - A library of local search heuristics for the vehicle routing problem, fecha de acceso: enero 3, 2026, https://opus4.kobv.de/opus4-mpc/files/16/Groer2010_Article_ALibraryOfLocalSearchHeuristic.pdf
LOCAL SEARCH IN ROUTING PROBLEMS WITH TIME ... - CORE, fecha de acceso: enero 3, 2026, https://core.ac.uk/download/pdf/193846555.pdf
The Vehicle Routing Problem with Time Windows: Minimizing Route Duration, fecha de acceso: enero 3, 2026, https://www.researchgate.net/publication/220669318_The_Vehicle_Routing_Problem_with_Time_Windows_Minimizing_Route_Duration
Efficient Move Evaluations for Time-Dependent Vehicle Routing Problems, fecha de acceso: enero 3, 2026, https://repub.eur.nl/pub/100852/EI2017-23.pdf
Research on Vehicle Routing Problem with Time Windows Based on Improved Genetic Algorithm and Ant Colony Algorithm - MDPI, fecha de acceso: enero 3, 2026, https://www.mdpi.com/2079-9292/14/4/647
An adaptive large neighborhood search algorithm for Vehicle Routing Problem with Multiple Time Windows constraints - ResearchGate, fecha de acceso: enero 3, 2026, https://www.researchgate.net/publication/356622283_An_adaptive_large_neighborhood_search_algorithm_for_Vehicle_Routing_Problem_with_Multiple_Time_Windows_constraints
Adaptive Large Neighborhood Search, fecha de acceso: enero 3, 2026, https://d-nb.info/1072464683/34
Insertion Heuristics for a Class of Dynamic Vehicle Routing Problems, fecha de acceso: enero 3, 2026, https://optimization-online.org/wp-content/uploads/2022/11/dynamic-insertion.pdf
A novel optimization method for hazardous materials vehicle routing with temperature-based time windows - NIH, fecha de acceso: enero 3, 2026, https://pmc.ncbi.nlm.nih.gov/articles/PMC11784799/
Lightweight Heuristic Selector - Emergent Mind, fecha de acceso: enero 3, 2026, https://www.emergentmind.com/topics/lightweight-heuristic-selector
VRPTW Benchmark Datasets - Kaggle, fecha de acceso: enero 3, 2026, https://www.kaggle.com/datasets/senju14/vrptw-benchmark-datasets
Features of solomon's VRPTW benchmark | Download Scientific Diagram - ResearchGate, fecha de acceso: enero 3, 2026, https://www.researchgate.net/figure/Features-of-solomons-VRPTW-benchmark_tbl1_366596071
